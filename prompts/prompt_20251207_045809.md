**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `devnet`
- **Package ID:** `0x2cee8b1650a8bbd38c81494a00bb46a370c7863593eac06b2fc0e55f739a7fab`
- **Module Name:** `meal_picker`
- **Available Methods:**

  * `pick_random` (constant: `PICK_RANDOM`)

---

# **Move Contract: `contract/random_meal_picker/sources/meal_picker.move`**

```move
module random_meal_picker::meal_picker {
use iota::object;
use iota::transfer;
use iota::tx_context;
public struct MealChoice has key, store {
id: object::UID,
index: u64,
seed: u64,
user: address,
}
const ERandomInvalidCount: u64 = 1;
public fun pick_random(
meal_count: u64,
seed: u64,
_ctx: &mut tx_context::TxContext
) {
assert!(meal_count > 0, ERandomInvalidCount);
let a: u64 = 1103515245;
let c: u64 = 12345;
let v = a * seed + c;
let index = v % meal_count;
let choice = MealChoice {
id: object::new(_ctx),
index,
seed,
user: tx_context::sender(_ctx),
};
transfer::public_transfer(choice, tx_context::sender(_ctx));
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client";

/**
 * ============================================================================
 * IOTA CONTRACT INTEGRATION HOOK - RANDOM MEAL PICKER
 * ============================================================================
 *
 * Hook n√†y ch·ª©a to√†n b·ªô logic t∆∞∆°ng t√°c smart contract cho dApp Random Meal Picker.
 * N√≥ g·ªçi h√†m `pick_random` trong Move module `meal_picker` ƒë·ªÉ t·∫°o m·ªôt object
 * MealChoice ch·ª©a index m√≥n ƒÉn ƒë√£ ch·ªçn.
 *
 * ============================================================================
 */

import { useState } from "react";
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit";
import { Transaction } from "@iota/iota-sdk/transactions";
import type { IotaObjectData } from "@iota/iota-sdk/client";

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================

// TODO: n·∫øu b·∫°n t·ª± deploy package c·ªßa m√¨nh, h√£y s·ª≠a l·∫°i ID n√†y cho kh·ªõp.
export const CONTRACT_PACKAGE_ID =
  "0x81a4f8880f8e625c1c4be31d7ca27638ed092278359e3fc143be6e0aa805325a";

export const CONTRACT_MODULE = "meal_picker";
export const CONTRACT_METHODS = {
  PICK_RANDOM: "pick_random",
} as const;

// ============================================================================
// DATA EXTRACTION
// ============================================================================

export interface ContractData {
  index: number;
  seed: number;
  user: string;
}

function getMealChoiceFields(data: IotaObjectData): ContractData | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("Data is not a moveObject:", data.content?.dataType);
    return null;
  }

  const fields = data.content.fields as Record<string, unknown>;
  if (!fields) {
    console.log("No fields found in object data");
    return null;
  }

  try {
    return {
      index: parseInt(String(fields.index), 10),
      seed: parseInt(String(fields.seed), 10),
      user: String(fields.user),
    };
  } catch (error) {
    console.error("Error parsing meal choice fields:", error);
    return null;
  }
}

// ============================================================================
// STATE TYPES
// ============================================================================

export interface ContractState {
  isLoading: boolean;
  isPending: boolean;
  isConfirming: boolean;
  isConfirmed: boolean;
  hash: string | undefined;
  error: Error | null;
}

export interface ContractActions {
  pickRandomMeal: (mealCount: number, seed: number) => Promise<void>;
  clearChoice: () => void;
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export const useContract = () => {
  const currentAccount = useCurrentAccount();
  const address = currentAccount?.address;
  const packageId = CONTRACT_PACKAGE_ID;
  const iotaClient = useIotaClient();
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction();

  const [choiceId, setChoiceId] = useState<string | null>(() => {
    if (typeof window !== "undefined" && currentAccount?.address) {
      return localStorage.getItem(`mealChoiceId_${currentAccount.address}`);
    }
    return null;
  });

  const [isLoading, setIsLoading] = useState(false);
  const [hash, setHash] = useState<string | undefined>();
  const [transactionError, setTransactionError] = useState<Error | null>(null);

  // Fetch MealChoice object
  const {
    data,
    isPending: isFetching,
    error: queryError,
    refetch,
  } = useIotaClientQuery(
    "getObject",
    {
      id: choiceId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!choiceId,
    }
  );

  const fields = data?.data ? getMealChoiceFields(data.data) : null;
  const objectExists = !!data?.data;
  const hasValidData = !!fields;

  // G·ªçi h√†m pick_random tr√™n chain
  const pickRandomMeal = async (mealCount: number, seed: number) => {
    if (!packageId) return;

    try {
      setTransactionError(null);
      setHash(undefined);

      const tx = new Transaction();
      tx.moveCall({
        arguments: [tx.pure.u64(mealCount), tx.pure.u64(seed)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.PICK_RANDOM}`,
      });

      signAndExecute(
        { transaction: tx as never },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest);
            setIsLoading(true);
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              });

              const created = effects?.created ?? [];
              const newChoiceId = created[0]?.reference?.objectId;

              if (newChoiceId) {
                setChoiceId(newChoiceId);
                if (typeof window !== "undefined" && address) {
                  localStorage.setItem(
                    `mealChoiceId_${address}`,
                    newChoiceId
                  );
                }
                await refetch();
              } else {
                console.warn("No MealChoice ID found in transaction effects");
              }
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError);
            } finally {
              setIsLoading(false);
            }
          },
          onError: (err) => {
            const error =
              err instanceof Error ? err : new Error(String(err));
            setTransactionError(error);
            console.error("Error:", err);
          },
        }
      );
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setTransactionError(error);
      console.error("Error calling pick_random:", err);
    }
  };

  const clearChoice = () => {
    setChoiceId(null);
    setTransactionError(null);
    setHash(undefined);
    if (typeof window !== "undefined" && address) {
      localStorage.removeItem(`mealChoiceId_${address}`);
    }
  };

  const actions: ContractActions = {
    pickRandomMeal,
    clearChoice,
  };

  const contractState: ContractState = {
    isLoading: isLoading || isFetching,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  };

  return {
    data: fields,
    actions,
    state: contractState,
    choiceId,
    objectExists,
    hasValidData,
    isFetching,
  };
};

```

---

# File 2: `components/sample.tsx`

```tsx
"use client";

/**
 * ============================================================================
 * RANDOM MEAL PICKER DAPP
 * ============================================================================
 *
 * Component n√†y cho ph√©p b·∫°n:
 *  - K·∫øt n·ªëi v√≠ IOTA
 *  - B·∫•m n√∫t "Pick Meal" ƒë·ªÉ g·ªçi smart contract `pick_random`
 *  - Hi·ªÉn th·ªã m√≥n ƒÉn ƒë∆∞·ª£c ch·ªçn ng·∫´u nhi√™n t·ª´ danh s√°ch c·ªë ƒë·ªãnh
 *
 * To√†n b·ªô logic contract n·∫±m trong hooks/useContract.ts
 * ============================================================================
 */

import { useState, useMemo } from "react";
import { useCurrentAccount } from "@iota/dapp-kit";
import { useContract } from "@/hooks/useContract";
import { Button, Container, Heading, Text, TextField } from "@radix-ui/themes";
import ClipLoader from "react-spinners/ClipLoader";

const MEALS = [
  "üç£ Sushi",
  "üçï Pizza",
  "üçî Burger",
  "üçú Ph·ªü",
  "ü•ó Salad",
  "üçõ Curry",
];

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount();
  const { data, actions, state, choiceId } = useContract();

  const [seedInput, setSeedInput] = useState<string>(() =>
    Math.floor(Math.random() * 100000).toString()
  );

  const isConnected = !!currentAccount;

  const { chosenMeal, chosenIndex } = useMemo(() => {
    if (!data)
      return {
        chosenMeal: null as string | null,
        chosenIndex: null as number | null,
      };
    const safeIndex = data.index % MEALS.length;
    return { chosenMeal: MEALS[safeIndex], chosenIndex: safeIndex };
  }, [data]);

  if (!isConnected) {
    return (
      <div
        style={{
          minHeight: "100vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "1rem",
        }}
      >
        <div style={{ maxWidth: "500px", width: "100%" }}>
          <Heading size="6" style={{ marginBottom: "1rem" }}>
            üçΩÔ∏è Random Meal Picker
          </Heading>
          <Text>
            H√£y k·∫øt n·ªëi v√≠ IOTA c·ªßa b·∫°n ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªçn m√≥n ng·∫´u nhi√™n cho c·∫£
            nh√≥m.
          </Text>
        </div>
      </div>
    );
  }

  return (
    <div
      style={{
        minHeight: "100vh",
        padding: "1rem",
        background: "var(--gray-a2)",
      }}
    >
      <Container style={{ maxWidth: "800px", margin: "0 auto" }}>
        <Heading size="6" style={{ marginBottom: "2rem" }}>
          üçΩÔ∏è Random Meal Picker
        </Heading>

        {/* K·∫øt qu·∫£ l·ª±a ch·ªçn hi·ªán t·∫°i */}
        {choiceId && data && (
          <div
            style={{
              marginBottom: "1rem",
              padding: "1.5rem",
              background: "var(--green-a3)",
              borderRadius: "8px",
              border: "2px solid var(--green-7)",
            }}
          >
            <Heading size="4" style={{ marginBottom: "0.5rem" }}>
              ‚úÖ ƒê√£ ch·ªçn m√≥n ƒÉn cho nh√≥m!
            </Heading>
            {chosenMeal && (
              <Text
                style={{
                  display: "block",
                  fontSize: "1.1rem",
                  marginBottom: "0.5rem",
                }}
              >
                M√≥n ƒë∆∞·ª£c ch·ªçn: <strong>{chosenMeal}</strong>
              </Text>
            )}
            <Text
              size="1"
              style={{
                color: "var(--gray-a11)",
                display: "block",
                fontFamily: "monospace",
                wordBreak: "break-all",
              }}
            >
              MealChoice ID: {choiceId}
            </Text>
            <Text
              size="1"
              style={{
                color: "var(--gray-a11)",
                display: "block",
                fontFamily: "monospace",
                marginTop: "0.25rem",
              }}
            >
              index: {data.index} ‚Ä¢ seed: {data.seed}
            </Text>
          </div>
        )}

        {/* Form ch·ªçn seed & g·ªçi pick_random */}
        <div
          style={{
            padding: "1.5rem",
            background: "var(--gray-a3)",
            borderRadius: "8px",
            marginBottom: "1rem",
          }}
        >
          <Heading size="4" style={{ marginBottom: "1rem" }}>
            Ch·ªçn m√≥n ng·∫´u nhi√™n üë®‚Äçüç≥
          </Heading>

          <Text size="2" style={{ display: "block", marginBottom: "0.5rem" }}>
            Danh s√°ch m√≥n ƒÉn (c·ªë ƒë·ªãnh tr√™n frontend):
          </Text>
          <ul style={{ marginBottom: "1rem", paddingLeft: "1.2rem" }}>
            {MEALS.map((meal, idx) => (
              <li key={idx}>
                <Text size="2">
                  #{idx} ‚Äì {meal}
                </Text>
              </li>
            ))}
          </ul>

          <div
            style={{
              display: "flex",
              flexDirection: "column",
              gap: "0.75rem",
              marginBottom: "1rem",
            }}
          >
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Seed (s·ªë b·∫•t k·ª≥ b·∫°n th√≠ch)
              </Text>
              <TextField.Root
                value={seedInput}
                onChange={(e) => setSeedInput(e.target.value)}
                type="number"
                min="0"
              />
              <Text
                size="1"
                style={{
                  display: "block",
                  marginTop: "0.25rem",
                  color: "var(--gray-a11)",
                }}
              >
                Seed d√πng l√†m ƒë·∫ßu v√†o cho smart contract ƒë·ªÉ t√≠nh to√°n ng·∫´u
                nhi√™n.
              </Text>
            </div>
          </div>

          <Button
            size="3"
            onClick={() =>
              actions.pickRandomMeal(
                MEALS.length,
                Number.isNaN(parseInt(seedInput, 10))
                  ? 0
                  : parseInt(seedInput, 10)
              )
            }
            disabled={state.isPending || state.isLoading}
          >
            {state.isLoading || state.isPending ? (
              <>
                <ClipLoader size={16} style={{ marginRight: "8px" }} />
                ƒêang ch·ªçn...
              </>
            ) : (
              "üé≤ Pick Meal"
            )}
          </Button>

          {data && chosenMeal && (
            <div
              style={{
                marginTop: "1rem",
                padding: "1rem",
                background: "var(--gray-a4)",
                borderRadius: "8px",
              }}
            >
              <Text size="2">
                K·∫øt qu·∫£ hi·ªán t·∫°i: <strong>{chosenMeal}</strong>{" "}
                {chosenIndex !== null && `(index ${chosenIndex})`}
              </Text>
            </div>
          )}
        </div>

        {/* Transaction Status */}
        {state.hash && (
          <div
            style={{
              marginTop: "1rem",
              padding: "1rem",
              background: "var(--gray-a3)",
              borderRadius: "8px",
            }}
          >
            <Text size="1" style={{ display: "block", marginBottom: "0.5rem" }}>
              Transaction Hash
            </Text>
            <Text
              size="2"
              style={{ fontFamily: "monospace", wordBreak: "break-all" }}
            >
              {state.hash}
            </Text>
            {state.isConfirmed && (
              <Text
                size="2"
                style={{
                  color: "green",
                  marginTop: "0.5rem",
                  display: "block",
                }}
              >
                ‚úÖ Transaction confirmed!
              </Text>
            )}
          </div>
        )}

        {/* Error Display */}
        {state.error && (
          <div
            style={{
              marginTop: "1rem",
              padding: "1rem",
              background: "var(--red-a3)",
              borderRadius: "8px",
            }}
          >
            <Text style={{ color: "var(--red-11)" }}>
              Error: {(state.error as Error)?.message || String(state.error)}
            </Text>
          </div>
        )}
      </Container>
    </div>
  );
};

export default SampleIntegration;

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x2cee8b1650a8bbd38c81494a00bb46a370c7863593eac06b2fc0e55f739a7fab` and Module: `meal_picker`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
